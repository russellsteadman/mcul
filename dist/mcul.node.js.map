{"version":3,"file":"mcul.node.js","sources":["webpack:///webpack/bootstrap","webpack:///../src/maps/atomicToAMU.js","webpack:///../src/maps/atomicToSymbol.js","webpack:///../src/maps/atomicToName.js","webpack:///../src/Atom.js","webpack:///../src/Molecule.js","webpack:///../src/mcul.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default [1.008, 4.003, 7, 9.012, 10.81, 12.011, 14.007, 15.999, 18.998, 20.18, 22.99, 24.305, 26.982, 28.085, 30.974, 32.07, 35.45, 39.9, 39.098, 40.08, 44.956, 47.87, 50.941, 51.996, 54.938, 55.84, 58.933, 58.693, 63.55, 65.4, 69.72, 72.63, 74.922, 78.97, 79.9, 83.8, 85.468, 87.6, 88.906, 91.22, 92.906, 96, 97.907, 101.1, 102.906, 106.4, 107.868, 112.41, 114.82, 118.71, 121.76, 127.6, 126.905, 131.29, 132.905, 137.33, 138.906, 140.12, 140.908, 144.24, 144.913, 150.4, 151.96, 157.2, 158.925, 162.5, 164.93, 167.26, 168.934, 173.04, 174.967, 178.5, 180.948, 183.8, 186.21, 190.2, 192.22, 195.08, 196.967, 200.59, 204.383, 207, 208.98, 208.982, 209.987, 222.018, 223.02, 226.025, 227.028, 232.038, 231.036, 238.029, 237.048, 244.064, 243.061, 247.07, 247.07, 251.08, 252.083, 257.095, 258.098, 259.101, 262.11, 267.122, 268.126, 271.134, 274.144, 277.152, 278.156, 281.165, 282.169, 285.177, 286.183, 289.191, 290.196, 293.205, 294.211, 294.214];","export default [\"H\", \"He\", \"Li\", \"Be\", \"B\", \"C\", \"N\", \"O\", \"F\", \"Ne\", \"Na\", \"Mg\", \"Al\", \"Si\", \"P\", \"S\", \"Cl\", \"Ar\", \"K\", \"Ca\", \"Sc\", \"Ti\", \"V\", \"Cr\", \"Mn\", \"Fe\", \"Co\", \"Ni\", \"Cu\", \"Zn\", \"Ga\", \"Ge\", \"As\", \"Se\", \"Br\", \"Kr\", \"Rb\", \"Sr\", \"Y\", \"Zr\", \"Nb\", \"Mo\", \"Tc\", \"Ru\", \"Rh\", \"Pd\", \"Ag\", \"Cd\", \"In\", \"Sn\", \"Sb\", \"Te\", \"I\", \"Xe\", \"Cs\", \"Ba\", \"La\", \"Ce\", \"Pr\", \"Nd\", \"Pm\", \"Sm\", \"Eu\", \"Gd\", \"Tb\", \"Dy\", \"Ho\", \"Er\", \"Tm\", \"Yb\", \"Lu\", \"Hf\", \"Ta\", \"W\", \"Re\", \"Os\", \"Ir\", \"Pt\", \"Au\", \"Hg\", \"Tl\", \"Pb\", \"Bi\", \"Po\", \"At\", \"Rn\", \"Fr\", \"Ra\", \"Ac\", \"Th\", \"Pa\", \"U\", \"Np\", \"Pu\", \"Am\", \"Cm\", \"Bk\", \"Cf\", \"Es\", \"Fm\", \"Md\", \"No\", \"Lr\", \"Rf\", \"Db\", \"Sg\", \"Bh\", \"Hs\", \"Mt\"];","export default [\"Hydrogen\", \"Helium\", \"Lithium\", \"Beryllium\", \"Boron\", \"Carbon\", \"Nitrogen\", \"Oxygen\", \"Fluorine\", \"Neon\", \"Sodium\", \"Magnesium\", \"Aluminum\", \"Silicon\", \"Phosphorus\", \"Sulfur\", \"Chlorine\", \"Argon\", \"Potassium\", \"Calcium\", \"Scandium\", \"Titanium\", \"Vanadium\", \"Chromium\", \"Manganese\", \"Iron\", \"Cobalt\", \"Nickel\", \"Copper\", \"Zinc\", \"Gallium\", \"Germanium\", \"Arsenic\", \"Selenium\", \"Bromine\", \"Krypton\", \"Rubidium\", \"Strontium\", \"Yttrium\", \"Zirconium\", \"Niobium\", \"Molybdenum\", \"Technetium\", \"Ruthenium\", \"Rhodium\", \"Palladium\", \"Silver\", \"Cadmium\", \"Indium\", \"Tin\", \"Antimony\", \"Tellurium\", \"Iodine\", \"Xenon\", \"Cesium\", \"Barium\", \"Lanthanum\", \"Cerium\", \"Praseodymium\", \"Neodymium\", \"Promethium\", \"Samarium\", \"Europium\", \"Gadolinium\", \"Terbium\", \"Dysprosium\", \"Holmium\", \"Erbium\", \"Thulium\", \"Ytterbium\", \"Lutetium\", \"Hafnium\", \"Tantalum\", \"Tungsten\", \"Rhenium\", \"Osmium\", \"Iridium\", \"Platinum\", \"Gold\", \"Mercury\", \"Thallium\", \"Lead\", \"Bismuth\", \"Polonium\", \"Astatine\", \"Radon\", \"Francium\", \"Radium\", \"Actinium\", \"Thorium\", \"Protactinium\", \"Uranium\", \"Neptunium\", \"Plutonium\", \"Americium\", \"Curium\", \"Berkelium\", \"Californium\", \"Einsteinium\", \"Fermium\", \"Mendelevium\", \"Nobelium\", \"Lawrencium\", \"Rutherfordium\", \"Dubnium\", \"Seaborgium\", \"Bohrium\", \"Hassium\", \"Meitnerium\"];","var _temp;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport AtomicToSymbol from './maps/atomicToSymbol';\nimport AtomicToName from './maps/atomicToName';\nimport AtomicToAMU from './maps/atomicToAMU';\nconst Atom = (_temp = class Atom {\n  constructor(el, p, id) {\n    _defineProperty(this, \"in\", molecule => {\n      if (!molecule || molecule.type !== 'molecule') throw new Error('Must pass in a Molecule instance');\n      this.s.p = molecule;\n      this.s.id = molecule.s.i.toString(36);\n      molecule.s.i += 1;\n      molecule.s.a[this.s.id] = this.s.a;\n      return this;\n    });\n\n    _defineProperty(this, \"clone\", () => {\n      let atom = new Atom();\n      atom.s.a = this.s.a;\n      return atom;\n    });\n\n    this.s = {\n      a: {\n        el: el ? typeof el === 'string' ? AtomicToSymbol.indexOf(el) + 1 : el : 0\n      },\n      p,\n      // Parent molecule\n      id // Id of atom in molecule\n\n    };\n    this.type = 'atom';\n  }\n\n  set symbol(symbol) {\n    this.atomic = AtomicToSymbol.indexOf(symbol) + 1;\n  }\n\n  set atomic(atomic) {\n    this.s.a.el = atomic;\n\n    if (this.s.p && this.s.id) {\n      this.s.p.s.a[this.s.id] = _objectSpread({}, this.s.p.s.a[this.s.id], {\n        el: atomic\n      });\n    }\n  }\n\n  get symbol() {\n    return AtomicToSymbol[this.s.a.el - 1] || '';\n  }\n\n  get name() {\n    return AtomicToName[this.s.a.el - 1] || '';\n  }\n\n  get atomic() {\n    return this.s.a.el;\n  }\n\n  get mass() {\n    return AtomicToAMU[this.s.a.el - 1] || 0;\n  } // Attach to a parent molecule\n\n\n}, _temp);\nexport default Atom;","var _temp;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport AtomicToAMU from './maps/atomicToAMU';\nimport AtomicToSymbol from './maps/atomicToSymbol';\nimport Atom from './Atom';\nconst SCHEMA_VERSION = 1;\nconst Molecule = (_temp = class Molecule {\n  constructor() {\n    _defineProperty(this, \"createAtom\", el => {\n      let id = this.s.i.toString(36);\n      this.s.i += 1;\n      let atom = new Atom(el, this, id);\n      this.s.a[id] = atom.s.a;\n      return atom;\n    });\n\n    _defineProperty(this, \"contains\", component => {\n      if (component) {\n        if (component.type === 'molecule') {\n          let index = this.s.i;\n\n          for (let i in component.s.a) {\n            let id = (parseInt(i, 36) + index).toString(36);\n            this.s.i += 1;\n            this.s.a[id] = component.s.a[i];\n          }\n\n          for (let i in component.s.b) {\n            if (!component.s.b) continue;\n            let [idOne, idTwo] = i.split('-');\n            idOne = (parseInt(idOne, 36) + index).toString(36);\n            idTwo = (parseInt(idTwo, 36) + index).toString(36);\n            this.s.b[`${idOne}-${idTwo}`] = component.s.b[i];\n            this.s.b[`${idTwo}-${idOne}`] = null;\n          }\n\n          delete component.s;\n          component.s = this.s;\n          return this;\n        } else if (component.type === 'atom') {\n          return component.in(this);\n        } else {\n          throw new Error('Must pass an molecule or atom');\n        }\n      } else {\n        throw new Error('Must pass a component');\n      }\n    });\n\n    _defineProperty(this, \"in\", molecule => {\n      if (!molecule || molecule.type !== 'molecule') throw new Error('Must pass in a Molecule instance');\n      return molecule.contains(this);\n    });\n\n    _defineProperty(this, \"getAtomById\", id => {\n      let atom = new Atom(null, this, id);\n      atom.s.a = this.s.a[id] || {};\n      return atom;\n    });\n\n    _defineProperty(this, \"getAtomsByElement\", el => {\n      el = el ? typeof el === 'string' ? AtomicToSymbol.indexOf(el) + 1 : el : 0;\n      let atoms = [];\n\n      for (let id in this.s.a) {\n        if (this.s.a[id].el !== el) continue;\n        let atom = new Atom(null, this, id);\n        atom.s.a = this.s.a[id] || {};\n        atoms.push(atom);\n      }\n\n      return atoms;\n    });\n\n    _defineProperty(this, \"getBondedAtoms\", atom => {\n      let id = atom && atom.s && atom.s.id;\n      let atoms = [];\n\n      for (let i in this.s.b) {\n        if (i.split('-')[0] !== id) continue;\n        let atom = new Atom(null, this, i.split('-')[1]);\n        atom.s.a = this.s.a[i.split('-')[1]] || {};\n        atoms.push(atom);\n      }\n\n      return atoms;\n    });\n\n    _defineProperty(this, \"getBranchPaths\", (atom, priorId, originalId) => {\n      let id = atom && atom.s && atom.s.id || atom;\n      let linearPrefix = priorId ? `-${id}` : id;\n      let branchLines = [];\n      let pathEnd = true; // Checking for originalId prevents looping for cyclic structures\n\n      if (id !== originalId) {\n        if (!originalId) originalId = id;\n\n        for (let i in this.s.b) {\n          if (i.split('-')[0] !== id || i.split('-')[1] === priorId) continue;\n          pathEnd = false;\n          branchLines = this.getBranchPaths(i.split('-')[1], id, originalId).concat(branchLines);\n        }\n      }\n\n      if (pathEnd) {\n        // This is the end of a path, so create a new branch\n        branchLines.push(linearPrefix);\n      } else {\n        // Add to all paths as a part in the change\n        for (let i in branchLines) {\n          branchLines[i] = linearPrefix + branchLines[i];\n        }\n      }\n\n      return branchLines;\n    });\n\n    _defineProperty(this, \"bond\", (atomOne, atomTwo, options) => {\n      let idOne = atomOne && atomOne.s && atomOne.s.id;\n      let idTwo = atomTwo && atomTwo.s && atomTwo.s.id;\n      this.s.b[`${idOne}-${idTwo}`] = _objectSpread({\n        type: 'c',\n        // One of: c (Covalent), i (Ionic), m (Metallic)\n        count: 1\n      }, options);\n      this.s.b[`${idTwo}-${idOne}`] = null;\n      return this;\n    });\n\n    _defineProperty(this, \"modifyBond\", (atomOne, atomTwo, changes) => {\n      let idOne = atomOne && atomOne.s && atomOne.s.id;\n      let idTwo = atomTwo && atomTwo.s && atomTwo.s.id;\n      let bond = this.s.b[`${idOne}-${idTwo}`];\n\n      if (typeof bond === 'object' && bond) {\n        this.s.b[`${idOne}-${idTwo}`] = _objectSpread({}, this.s.b[`${idOne}-${idTwo}`], {}, changes);\n      } else if (typeof bond === 'object' && !bond) {\n        this.s.b[`${idTwo}-${idOne}`] = _objectSpread({}, this.s.b[`${idTwo}-${idOne}`], {}, changes);\n      } else {\n        throw new Error('Unable to modify bond, does not exist');\n      }\n    });\n\n    _defineProperty(this, \"getBond\", (atomOne, atomTwo) => {\n      let idOne = atomOne && atomOne.s && atomOne.s.id;\n      let idTwo = atomTwo && atomTwo.s && atomTwo.s.id;\n      let bond = this.s.b[`${idOne}-${idTwo}`];\n\n      if (typeof bond === 'object' && bond) {\n        return bond;\n      } else if (typeof bond === 'object' && !bond) {\n        return this.s.b[`${idTwo}-${idOne}`];\n      } else {\n        return null;\n      }\n    });\n\n    _defineProperty(this, \"pack\", () => {\n      return JSON.stringify({\n        v: SCHEMA_VERSION,\n        s: this.s\n      });\n    });\n\n    _defineProperty(this, \"unpack\", packed => {\n      try {\n        let pack = JSON.parse(packed);\n        if (pack.v > SCHEMA_VERSION) throw new Error('Upgrade mcul to use newer package schema');\n        this.s = pack.s;\n      } catch (e) {\n        throw new Error('Unable to parse packed data');\n      }\n    });\n\n    _defineProperty(this, \"clone\", () => {\n      let double = new Molecule();\n      double.s = JSON.parse(JSON.stringify(this.s));\n      return double;\n    });\n\n    this.s = {\n      a: {},\n      // Atoms mapped \"id\" -> information\n      b: {},\n      // Bonds mapped \"id-id\" -> information\n      i: 0 // Index, beginning at 0\n\n    };\n    this.type = 'molecule';\n  } // Create a new atom\n\n\n  get mass() {\n    let mass = 0;\n\n    for (let i in this.s.a) {\n      mass += AtomicToAMU[this.s.a[i].el - 1] || 0;\n    }\n\n    return Math.round(mass * 1000) / 1000;\n  }\n\n}, _temp);\nexport default Molecule;","import Molecule from './Molecule';\nimport Atom from './Atom';\nexport { Molecule, Atom };"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClFA;;ACAA;;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjNA;AACA;;;;A","sourceRoot":""}