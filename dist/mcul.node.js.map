{"version":3,"file":"mcul.node.js","sources":["webpack:///webpack/bootstrap","webpack:///../src/maps/atomicToAMU.js","webpack:///../src/maps/atomicToSymbol.js","webpack:///../src/maps/atomicToName.js","webpack:///../src/Atom.js","webpack:///../src/maps/alkyl.js","webpack:///../src/ext/Add.js","webpack:///../src/Molecule.js","webpack:///../src/mcul.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default [1.008, 4.003, 7, 9.012, 10.81, 12.011, 14.007, 15.999, 18.998, 20.18, 22.99, 24.305, 26.982, 28.085, 30.974, 32.07, 35.45, 39.9, 39.098, 40.08, 44.956, 47.87, 50.941, 51.996, 54.938, 55.84, 58.933, 58.693, 63.55, 65.4, 69.72, 72.63, 74.922, 78.97, 79.9, 83.8, 85.468, 87.6, 88.906, 91.22, 92.906, 96, 97.907, 101.1, 102.906, 106.4, 107.868, 112.41, 114.82, 118.71, 121.76, 127.6, 126.905, 131.29, 132.905, 137.33, 138.906, 140.12, 140.908, 144.24, 144.913, 150.4, 151.96, 157.2, 158.925, 162.5, 164.93, 167.26, 168.934, 173.04, 174.967, 178.5, 180.948, 183.8, 186.21, 190.2, 192.22, 195.08, 196.967, 200.59, 204.383, 207, 208.98, 208.982, 209.987, 222.018, 223.02, 226.025, 227.028, 232.038, 231.036, 238.029, 237.048, 244.064, 243.061, 247.07, 247.07, 251.08, 252.083, 257.095, 258.098, 259.101, 262.11, 267.122, 268.126, 271.134, 274.144, 277.152, 278.156, 281.165, 282.169, 285.177, 286.183, 289.191, 290.196, 293.205, 294.211, 294.214];","export default [\"H\", \"He\", \"Li\", \"Be\", \"B\", \"C\", \"N\", \"O\", \"F\", \"Ne\", \"Na\", \"Mg\", \"Al\", \"Si\", \"P\", \"S\", \"Cl\", \"Ar\", \"K\", \"Ca\", \"Sc\", \"Ti\", \"V\", \"Cr\", \"Mn\", \"Fe\", \"Co\", \"Ni\", \"Cu\", \"Zn\", \"Ga\", \"Ge\", \"As\", \"Se\", \"Br\", \"Kr\", \"Rb\", \"Sr\", \"Y\", \"Zr\", \"Nb\", \"Mo\", \"Tc\", \"Ru\", \"Rh\", \"Pd\", \"Ag\", \"Cd\", \"In\", \"Sn\", \"Sb\", \"Te\", \"I\", \"Xe\", \"Cs\", \"Ba\", \"La\", \"Ce\", \"Pr\", \"Nd\", \"Pm\", \"Sm\", \"Eu\", \"Gd\", \"Tb\", \"Dy\", \"Ho\", \"Er\", \"Tm\", \"Yb\", \"Lu\", \"Hf\", \"Ta\", \"W\", \"Re\", \"Os\", \"Ir\", \"Pt\", \"Au\", \"Hg\", \"Tl\", \"Pb\", \"Bi\", \"Po\", \"At\", \"Rn\", \"Fr\", \"Ra\", \"Ac\", \"Th\", \"Pa\", \"U\", \"Np\", \"Pu\", \"Am\", \"Cm\", \"Bk\", \"Cf\", \"Es\", \"Fm\", \"Md\", \"No\", \"Lr\", \"Rf\", \"Db\", \"Sg\", \"Bh\", \"Hs\", \"Mt\"];","export default [\"Hydrogen\", \"Helium\", \"Lithium\", \"Beryllium\", \"Boron\", \"Carbon\", \"Nitrogen\", \"Oxygen\", \"Fluorine\", \"Neon\", \"Sodium\", \"Magnesium\", \"Aluminum\", \"Silicon\", \"Phosphorus\", \"Sulfur\", \"Chlorine\", \"Argon\", \"Potassium\", \"Calcium\", \"Scandium\", \"Titanium\", \"Vanadium\", \"Chromium\", \"Manganese\", \"Iron\", \"Cobalt\", \"Nickel\", \"Copper\", \"Zinc\", \"Gallium\", \"Germanium\", \"Arsenic\", \"Selenium\", \"Bromine\", \"Krypton\", \"Rubidium\", \"Strontium\", \"Yttrium\", \"Zirconium\", \"Niobium\", \"Molybdenum\", \"Technetium\", \"Ruthenium\", \"Rhodium\", \"Palladium\", \"Silver\", \"Cadmium\", \"Indium\", \"Tin\", \"Antimony\", \"Tellurium\", \"Iodine\", \"Xenon\", \"Cesium\", \"Barium\", \"Lanthanum\", \"Cerium\", \"Praseodymium\", \"Neodymium\", \"Promethium\", \"Samarium\", \"Europium\", \"Gadolinium\", \"Terbium\", \"Dysprosium\", \"Holmium\", \"Erbium\", \"Thulium\", \"Ytterbium\", \"Lutetium\", \"Hafnium\", \"Tantalum\", \"Tungsten\", \"Rhenium\", \"Osmium\", \"Iridium\", \"Platinum\", \"Gold\", \"Mercury\", \"Thallium\", \"Lead\", \"Bismuth\", \"Polonium\", \"Astatine\", \"Radon\", \"Francium\", \"Radium\", \"Actinium\", \"Thorium\", \"Protactinium\", \"Uranium\", \"Neptunium\", \"Plutonium\", \"Americium\", \"Curium\", \"Berkelium\", \"Californium\", \"Einsteinium\", \"Fermium\", \"Mendelevium\", \"Nobelium\", \"Lawrencium\", \"Rutherfordium\", \"Dubnium\", \"Seaborgium\", \"Bohrium\", \"Hassium\", \"Meitnerium\"];","var _temp;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport AtomicToSymbol from './maps/atomicToSymbol';\nimport AtomicToName from './maps/atomicToName';\nimport AtomicToAMU from './maps/atomicToAMU';\nconst Atom = (_temp = class Atom {\n  constructor(el, p, id) {\n    _defineProperty(this, \"in\", molecule => {\n      if (!molecule || molecule.type !== 'molecule') throw new Error('Must pass in a Molecule instance');\n      this.s.p = molecule;\n      this.s.id = molecule.s.i.toString(36);\n      molecule.s.i += 1;\n      molecule.s.a[this.s.id] = this.s.a;\n      return this;\n    });\n\n    _defineProperty(this, \"clone\", () => {\n      let atom = new Atom();\n      atom.s.a = this.s.a;\n      return atom;\n    });\n\n    this.s = {\n      a: {\n        el: el ? typeof el === 'string' ? AtomicToSymbol.indexOf(el) + 1 : el : 0\n      },\n      p,\n      // Parent molecule\n      id // Id of atom in molecule\n\n    };\n    this.type = 'atom';\n  }\n\n  set symbol(symbol) {\n    this.atomic = AtomicToSymbol.indexOf(symbol) + 1;\n  }\n\n  set atomic(atomic) {\n    this.s.a.el = atomic;\n\n    if (this.s.p && this.s.id) {\n      this.s.p.s.a[this.s.id] = _objectSpread({}, this.s.p.s.a[this.s.id], {\n        el: atomic\n      });\n    }\n  }\n\n  set charge(charge) {\n    if (typeof charge !== 'number') throw new Error('Charge must be an integer');\n    this.s.a.c = charge || 0;\n\n    if (this.s.p && this.s.id) {\n      this.s.p.s.a[this.s.id] = _objectSpread({}, this.s.p.s.a[this.s.id], {\n        c: charge\n      });\n    }\n  }\n\n  get charge() {\n    return this.s.a.c || 0;\n  }\n\n  get symbol() {\n    return AtomicToSymbol[this.s.a.el - 1] || '';\n  }\n\n  get name() {\n    return AtomicToName[this.s.a.el - 1] || '';\n  }\n\n  get atomic() {\n    return this.s.a.el;\n  }\n\n  get mass() {\n    return AtomicToAMU[this.s.a.el - 1] || 0;\n  } // Attach to a parent molecule\n\n\n}, _temp);\nexport default Atom;","export default ['methyl', 'ethyl', 'propyl', 'butyl', 'pentyl', 'hexyl', 'heptyl', 'octyl', 'nonyl', 'decyl', 'undecyl', 'dodecyl'];","import Alkyl from '../maps/alkyl';\nconst Isoalkyl = Alkyl.slice(2).map(alkyl => `iso${alkyl}`);\nconst Halide = ['fluoro', 'chloro', 'bromo', 'iodo'];\n\nconst Add = function (name, carbon, carbonTwo) {\n  if (Alkyl.indexOf(name) !== -1) {\n    // Add an alkyl group\n    let plus = this.chainCarbons(Alkyl.indexOf(name) + 1);\n    this.bond(plus[0], carbon);\n\n    for (let i in plus) this.hydrogenateCarbon(plus[i]);\n  } else if (Isoalkyl.indexOf(name) !== -1) {\n    // Add an isoalkyl group\n    let plus = this.chainCarbons(Alkyl.indexOf(name) + 1);\n    let carbons = this.createAtoms('C', 2);\n    this.bond(plus[plus.length - 1], carbons[0]).bond(plus[plus.length - 1], carbons[1]).bond(plus[0], carbon);\n\n    for (let i in plus) this.hydrogenateCarbon(plus[i]);\n\n    for (let i in carbons) this.hydrogenateCarbon(carbons[i]);\n  } else if (name === 's-butyl' || name === 'sec-butyl') {\n    // Add an s-butyl\n    let plus = this.chainCarbons(3);\n    let sub = this.createAtom('C');\n    this.bond(plus[1], sub).bond(plus[0], carbon);\n\n    for (let i in plus) this.hydrogenateCarbon(plus[i]);\n\n    this.hydrogenateCarbon(sub);\n  } else if (name === 't-butyl' || name === 'tert-butyl') {\n    // Add an t-butyl\n    let plus = this.chainCarbons(2);\n    let carbons = this.createAtoms('C', 2);\n    this.bond(plus[1], carbons[0]).bond(plus[1], carbons[1]).bond(plus[0], carbon);\n\n    for (let i in plus) this.hydrogenateCarbon(plus[i]);\n\n    for (let i in carbons) this.hydrogenateCarbon(carbons[i]);\n  } else if (name === 'benzene') {\n    // Add an benzene ring\n    let plus = this.chainCarbons(6, 1);\n\n    for (let i = 0; i < 6; i += 2) this.modifyBond(plus[i], plus[i + 1], {\n      count: 2\n    });\n\n    this.bond(plus[0], plus[5]).bond(plus[0], carbon);\n\n    for (let i in plus) this.hydrogenateCarbon(plus[i]);\n  } else if (name === 'amine') {\n    // Add an amine\n    let n = this.createAtom('N');\n    let h = this.createAtoms('H', 2);\n    this.bond(carbon, n).bond(n, h[0]).bond(n, h[1]);\n  } else if (Halide.indexOf(name) !== -1) {\n    // Add a halide\n    this.bond(this.createAtom(['F', 'Cl', 'Br', 'I'][Halide.indexOf(name)]), carbon);\n  } else if (name === 'hydroxyl') {\n    // Add an alcohol\n    let o = this.createAtom('O');\n    this.bond(o, this.createAtom('H')).bond(o, carbon);\n  } else if (name === 'carbonyl') {\n    // Add a ketone\n    let o = this.createAtom('O');\n    this.bond(o, carbon, {\n      count: 2\n    });\n  } else if (name === 'aldehyde') {\n    // Add a ketone\n    let o = this.createAtom('O');\n    this.bond(o, carbon, {\n      count: 2\n    });\n    if (this.getBondCount(carbon) < 4) this.bond(carbon, this.createAtom('H'));\n  } else if (name === 'carbonate') {\n    // Add a carbonate\n    if (!carbonTwo) throw new Error('Must provide a second R group for a carbonate');\n    let o = this.createAtoms('O', 3);\n    let c = this.createAtom('C');\n    this.bond(o[0], c, {\n      count: 2\n    }).bond(o[1], c).bond(o[2], c);\n    this.bond(carbon, o[1]).bond(carbonTwo, o[2]).bond(c, this.createAtom('H'));\n  } else if (name === 'carboxylate') {\n    let o = this.createAtoms('O', 2);\n    o[0].charge = -1;\n    this.bond(o[1], carbon, {\n      count: 2\n    }).bond(o[0], carbon);\n  } else if (name === 'carboxyl') {\n    let o = this.createAtoms('O', 2);\n    o[0].charge = -1;\n    this.bond(o[1], carbon, {\n      count: 2\n    }).bond(o[0], carbon);\n  } else {\n    throw new Error(`Unable to resolve functional group \"${name}\"`);\n  }\n};\n\nexport default Add;","var _temp;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport AtomicToAMU from './maps/atomicToAMU';\nimport AtomicToSymbol from './maps/atomicToSymbol';\nimport Atom from './Atom';\nimport Add from './ext/Add';\nconst SCHEMA_VERSION = 1;\nconst Molecule = (_temp = class Molecule {\n  constructor() {\n    _defineProperty(this, \"createAtom\", el => {\n      let id = this.s.i.toString(36);\n      this.s.i += 1;\n      let atom = new Atom(el, this, id);\n      this.s.a[id] = atom.s.a;\n      return atom;\n    });\n\n    _defineProperty(this, \"createAtoms\", (el, count) => {\n      let atoms = [];\n      if (typeof count !== 'number' || count < 1) throw new Error('Count must be a positive number');\n\n      for (let i = 0; i < count; i++) {\n        let id = this.s.i.toString(36);\n        this.s.i += 1;\n        atoms.push(new Atom(el, this, id));\n        this.s.a[id] = atoms[i].s.a;\n      }\n\n      return atoms;\n    });\n\n    _defineProperty(this, \"contains\", atom => {\n      if (atom && atom.type === 'atom') {\n        return atom.in(this);\n      } else {\n        throw new Error('Must pass an atom');\n      }\n    });\n\n    _defineProperty(this, \"getAtomById\", id => {\n      if (id && id.type === 'atom') return id;\n      let atom = new Atom(null, this, id);\n      atom.s.a = this.s.a[id] || {};\n      return atom;\n    });\n\n    _defineProperty(this, \"getAtomId\", atom => {\n      if (typeof atom === 'string') return atom;\n      atom = atom && atom.s && atom.s.id;\n      if (typeof atom !== 'string') throw new Error('Not an atom');\n      return atom;\n    });\n\n    _defineProperty(this, \"getAtomsByElement\", el => {\n      el = el ? typeof el === 'string' ? AtomicToSymbol.indexOf(el) + 1 : el : 0;\n      let atoms = [];\n\n      for (let id in this.s.a) {\n        if (this.s.a[id].el !== el) continue;\n        atoms.push(this.getAtomById(id));\n      }\n\n      return atoms;\n    });\n\n    _defineProperty(this, \"getBondedAtoms\", atom => {\n      let id = this.getAtomId(atom);\n      let atoms = [];\n\n      for (let i in this.s.b) {\n        if (i.split('-')[0] !== id) continue;\n        atoms.push(this.getAtomById(i.split('-')[1]));\n      }\n\n      return atoms;\n    });\n\n    _defineProperty(this, \"getBondCount\", atom => {\n      let id = this.getAtomId(atom);\n      let count = 0;\n      let bond;\n\n      for (let i in this.s.b) {\n        bond = this.s.b[i];\n        if (!bond) bond = this.s.b[`${i.split('-')[1]}-${i.split('-')[0]}`];\n        if (i.split('-')[0] === id) count += bond.count || 1;\n      }\n\n      return count;\n    });\n\n    _defineProperty(this, \"getBranchPaths\", (atom, priorId, originalId) => {\n      let id = this.getAtomId(atom);\n      let linearPrefix = priorId ? `-${id}` : id;\n      let branchLines = [];\n      let pathEnd = true; // Checking for originalId prevents looping for cyclic structures\n\n      if (id !== originalId) {\n        if (!originalId) originalId = id;\n\n        for (let i in this.s.b) {\n          if (i.split('-')[0] !== id || i.split('-')[1] === priorId) continue;\n          pathEnd = false;\n          branchLines = this.getBranchPaths(i.split('-')[1], id, originalId).concat(branchLines);\n        }\n      }\n\n      if (pathEnd) {\n        // This is the end of a path, so create a new branch\n        branchLines.push(linearPrefix);\n      } else {\n        // Add to all paths as a part in the change\n        for (let i in branchLines) {\n          branchLines[i] = linearPrefix + branchLines[i];\n        }\n      }\n\n      return branchLines;\n    });\n\n    _defineProperty(this, \"bond\", (atomOne, atomTwo, options) => {\n      let idOne = this.getAtomId(atomOne);\n      let idTwo = this.getAtomId(atomTwo);\n      this.s.b[`${idOne}-${idTwo}`] = _objectSpread({\n        type: 'c',\n        // One of: c (Covalent), i (Ionic), m (Metallic)\n        count: 1\n      }, options);\n      this.s.b[`${idTwo}-${idOne}`] = null;\n      return this;\n    });\n\n    _defineProperty(this, \"modifyBond\", (atomOne, atomTwo, changes) => {\n      let idOne = this.getAtomId(atomOne);\n      let idTwo = this.getAtomId(atomTwo);\n      let bond = this.s.b[`${idOne}-${idTwo}`];\n\n      if (typeof bond === 'object' && bond) {\n        this.s.b[`${idOne}-${idTwo}`] = _objectSpread({}, this.s.b[`${idOne}-${idTwo}`], {}, changes);\n      } else if (typeof bond === 'object' && !bond) {\n        this.s.b[`${idTwo}-${idOne}`] = _objectSpread({}, this.s.b[`${idTwo}-${idOne}`], {}, changes);\n      } else {\n        throw new Error('Unable to modify bond, does not exist');\n      }\n    });\n\n    _defineProperty(this, \"getBond\", (atomOne, atomTwo) => {\n      let idOne = this.getAtomId(atomOne);\n      let idTwo = this.getAtomId(atomTwo);\n      let bond = this.s.b[`${idOne}-${idTwo}`];\n\n      if (typeof bond === 'object' && bond) {\n        return bond;\n      } else if (typeof bond === 'object' && !bond) {\n        return this.s.b[`${idTwo}-${idOne}`];\n      } else {\n        return null;\n      }\n    });\n\n    _defineProperty(this, \"pack\", () => {\n      return JSON.stringify({\n        v: SCHEMA_VERSION,\n        s: this.s\n      });\n    });\n\n    _defineProperty(this, \"unpack\", packed => {\n      try {\n        let pack = JSON.parse(packed);\n        if (pack.v > SCHEMA_VERSION) throw new Error('Upgrade mcul to use newer package schema');\n        this.s = pack.s;\n      } catch (e) {\n        throw new Error('Unable to parse packed data');\n      }\n\n      return this;\n    });\n\n    _defineProperty(this, \"chainCarbons\", (count, bondCount) => {\n      if (!bondCount) bondCount = 1;\n\n      if (bondCount < 1 && bondCount > 3 || bondCount === 3 && count > 2) {\n        throw new Error('Chain must have a possible number of bonds');\n      }\n\n      let carbons = this.createAtoms('C', count);\n\n      for (let i = 1; i < count; i++) {\n        this.bond(carbons[i - 1], carbons[i], {\n          count: bondCount\n        });\n      }\n\n      return carbons;\n    });\n\n    _defineProperty(this, \"hydrogenateCarbon\", carbon => {\n      let bondCount = this.getBondCount(carbon);\n\n      for (let o = bondCount; o < 4; o++) {\n        let hydrogen = this.createAtom('H');\n        this.bond(carbon, hydrogen);\n      }\n\n      return this;\n    });\n\n    _defineProperty(this, \"hydrogenateCarbons\", () => {\n      let carbons = this.getAtomsByElement('C');\n\n      for (let i in carbons) {\n        let bondCount = this.getBondCount(carbons[i]);\n\n        for (let o = bondCount; o < 4; o++) {\n          let hydrogen = this.createAtom('H');\n          this.bond(carbons[i], hydrogen);\n        }\n      }\n\n      return this;\n    });\n\n    _defineProperty(this, \"clone\", () => {\n      let double = new Molecule();\n      double.s = JSON.parse(JSON.stringify(this.s));\n      return double;\n    });\n\n    this.s = {\n      a: {},\n      // Atoms mapped \"id\" -> information\n      b: {},\n      // Bonds mapped \"id-id\" -> information\n      i: 0 // Index, beginning at 0\n\n    };\n    this.type = 'molecule';\n    this.add = Add.bind(this);\n  } // Create a new atom\n\n\n  get mass() {\n    let mass = 0;\n\n    for (let i in this.s.a) {\n      mass += AtomicToAMU[this.s.a[i].el - 1] || 0;\n    }\n\n    return Math.round(mass * 1000) / 1000;\n  }\n\n  get atomCounts() {\n    let counts = {};\n    let countsSymbol = {};\n\n    for (let i in this.s.a) {\n      counts[this.s.a[i].el] = counts[this.s.a[i].el] || 0;\n      counts[this.s.a[i].el]++;\n    }\n\n    for (let i in counts) countsSymbol[AtomicToSymbol[Number(i) - 1]] = counts[i];\n\n    return {\n      symbol: countsSymbol,\n      atomic: counts\n    };\n  }\n\n  get moleFraction() {\n    let counts = {};\n    let countsSymbol = {};\n    let total = 0;\n\n    for (let i in this.s.a) {\n      counts[this.s.a[i].el] = counts[this.s.a[i].el] || 0;\n      counts[this.s.a[i].el]++;\n      total++;\n    }\n\n    for (let i in counts) {\n      counts[i] /= total;\n      counts[i] = Math.round(counts[i] * 10000) / 10000;\n      countsSymbol[AtomicToSymbol[Number(i) - 1]] = counts[i];\n    }\n\n    return {\n      symbol: countsSymbol,\n      atomic: counts\n    };\n  }\n\n  get massFraction() {\n    let counts = {};\n    let countsSymbol = {};\n    let total = 0;\n\n    for (let i in this.s.a) {\n      counts[this.s.a[i].el] = counts[this.s.a[i].el] || 0;\n      counts[this.s.a[i].el] += AtomicToAMU[this.s.a[i].el - 1];\n      total += AtomicToAMU[this.s.a[i].el - 1];\n    }\n\n    for (let i in counts) {\n      counts[i] /= total;\n      counts[i] = Math.round(counts[i] * 10000) / 10000;\n      countsSymbol[AtomicToSymbol[Number(i) - 1]] = counts[i];\n    }\n\n    return {\n      symbol: countsSymbol,\n      atomic: counts\n    };\n  }\n\n}, _temp);\nexport default Molecule;","import Molecule from './Molecule';\nimport Atom from './Atom';\nexport { Molecule, Atom };"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClFA;;ACAA;;ACAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClUA;AACA;;;;A","sourceRoot":""}