{"version":3,"file":"mcul.node.js","sources":["webpack:///webpack/bootstrap","webpack:///../src/shared/Collection.js","webpack:///../src/shared/types.js","webpack:///../src/shared/combinator.js","webpack:///../src/mcul.js","webpack:///../src/Molecule.js","webpack:///../src/parsers/basic.js","webpack:///../src/shared/convertToAtomic.js","webpack:///../src/parsers/iupac.js","webpack:///../src/Element.js","webpack:///../src/Subgroup.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst Types = require('./types');\n\nconst AtomicToAMU = require('./../maps/atomicToAMU.json');\n\nconst getCounts = function getCounts() {\n  let counts = {};\n\n  for (let i in this.children) {\n    if (this.children[i].type === Types.element[0]) {\n      counts[this.children[i].element] = counts[this.children[i].element] || 0;\n      counts[this.children[i].element] += this.children[i].count || 1;\n    } else {\n      let groupCount = this.children[i].counts;\n\n      for (let o in groupCount) {\n        if (this.children[i].count) groupCount[o] *= this.children[i].count;\n        counts[o] = (groupCount[o] || 0) + (counts[o] || 0);\n      }\n    }\n  }\n\n  return counts;\n};\n\nconst getMass = function getMass() {\n  const counts = getCounts.call(this);\n  let sum = 0;\n\n  for (let i in counts) {\n    sum += AtomicToAMU[Number(i) - 1] * counts[i];\n  }\n\n  return this.type === 'molecule' ? Math.round(sum * 1000) / 1000 : sum;\n};\n\nconst append = function append(item) {\n  if (!item || Types.all.indexOf(item.type) === -1) throw new Error('Cannot append invalid item');\n  this.children.push(item);\n};\n\nconst appendAll = function appendAll(items) {\n  for (let i in items) {\n    append.call(this, items[i]);\n  }\n};\n\nconst findById = function findById(self, id) {\n  if (id === false) return self;\n  const members = this.children;\n\n  for (let i in members) {\n    if (members[i].id === id) return members[i];\n\n    if (typeof members[i].findById === 'function') {\n      let subsearch = members[i].findById(id);\n      if (subsearch) return subsearch;\n    }\n  }\n\n  return null;\n};\n\nconst getChildIds = function getChildIds() {\n  let ids = {};\n\n  for (let i in this.children) {\n    ids[this.children[i].id] = this.children[i];\n\n    if (this.children[i].childIds) {\n      ids = _objectSpread({}, ids, {}, this.children[i].childIds);\n    }\n  }\n\n  return ids;\n};\n\nconst getParent = function getParent() {\n  const childIds = this.molecule.childIds;\n\n  for (let i in childIds) {\n    if (childIds[i].children) {\n      for (let o in childIds[i].children) {\n        if (childIds[i].children[o].id === this.id) {\n          return childIds[i];\n        }\n      }\n    }\n  }\n\n  return this.molecule;\n};\n\nconst getElementFraction = function getElementFraction(element) {\n  const counts = getCounts.call(this);\n  let sum = 0;\n\n  for (let i in counts) {\n    sum += counts[i] || 0;\n  }\n\n  return (counts[element] || 0) / sum;\n};\n\nconst getMassFraction = function getMassFraction(element) {\n  const counts = getCounts.call(this);\n  const mass = getMass.call(this);\n  (counts[element] || 0) * AtomicToAMU[Number(element) - 1] / mass;\n};\n\nmodule.exports = {\n  getCounts,\n  getMass,\n  append,\n  appendAll,\n  findById,\n  getChildIds,\n  getParent,\n  getElementFraction,\n  getMassFraction\n};","let Types = {\n  subgroup: ['subgroup', 'complex', 'chain', 'fngroup'],\n  element: ['element']\n};\nTypes.all = Types.subgroup.concat(Types.element);\nmodule.exports = Types;","module.exports = function (gen) {\n  return function (f) {\n    return f(f);\n  }(function (f) {\n    return gen(function () {\n      return f(f).apply(null, arguments);\n    });\n  });\n};","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to get private field on non-instance\"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nconst Molecule = require('./Molecule');\n\nclass Generator {\n  constructor() {\n    _state.set(this, {\n      writable: true,\n      value: {\n        parsers: {},\n        defaultFormat: 'basic'\n      }\n    });\n\n    _defineProperty(this, \"create\", options => {\n      return new Molecule(_objectSpread({}, options, {\n        parsers: _classPrivateFieldGet(this, _state).parsers,\n        parent: this\n      }));\n    });\n\n    _defineProperty(this, \"createFromText\", (rawText, format, options) => {\n      if (!format) format = _classPrivateFieldGet(this, _state).defaultFormat;\n      return new Molecule(_objectSpread({}, options, {\n        parsers: _classPrivateFieldGet(this, _state).parsers,\n        rawText,\n        format,\n        parent: this\n      }));\n    });\n\n    _defineProperty(this, \"setDefaultFormat\", format => {\n      _classPrivateFieldGet(this, _state).defaultFormat = format;\n    });\n\n    _defineProperty(this, \"addParser\", (parser, format) => {\n      if (typeof parser !== 'function' && typeof format !== 'string') {\n        throw new Error('Parser and format must be specified.');\n      }\n\n      _classPrivateFieldGet(this, _state).parsers[format] = parser;\n    });\n  }\n\n}\n\nvar _state = new WeakMap();\n\nmodule.exports = new Generator();","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to set private field on non-instance\"); } if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to get private field on non-instance\"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nconst Basic = require('./parsers/basic');\n\nconst Iupac = require('./parsers/iupac');\n\nconst Element = require('./Element');\n\nconst Subgroup = require('./Subgroup');\n\nconst Collection = require('./shared/Collection');\n\nconst Types = require('./shared/types');\n\nconst SCHEMA_VERSION = '0.1.0';\n\nclass Molecule {\n  constructor(_ref) {\n    let _rawText = _ref.rawText,\n        _format = _ref.format,\n        parent = _ref.parent,\n        _options = _objectWithoutProperties(_ref, [\"rawText\", \"format\", \"parent\"]);\n\n    _state.set(this, {\n      writable: true,\n      value: {\n        type: 'molecule',\n        children: [],\n        idIndex: 0,\n        formats: ['basic', 'iupac'],\n        bonds: {}\n      }\n    });\n\n    _createId.set(this, {\n      writable: true,\n      value: () => {\n        _classPrivateFieldGet(this, _state).idIndex += 1;\n        return _classPrivateFieldGet(this, _state).idIndex.toString(36);\n      }\n    });\n\n    _defineProperty(this, \"findById\", Collection.findById.bind(_classPrivateFieldGet(this, _state), this));\n\n    _defineProperty(this, \"serialize\", () => {\n      let children = Array.prototype.slice.call(_classPrivateFieldGet(this, _state).children);\n\n      for (let i in children) {\n        if (typeof children[i].serialize === 'function') {\n          children[i] = children[i].serialize();\n        }\n      }\n\n      return _objectSpread({\n        type: 'molecule',\n        version: SCHEMA_VERSION,\n        children,\n        bonds: _classPrivateFieldGet(this, _state).bonds,\n        idIndex: _classPrivateFieldGet(this, _state).idIndex\n      }, _classPrivateFieldGet(this, _state).rawText ? {\n        fromText: _classPrivateFieldGet(this, _state).rawText\n      } : {});\n    });\n\n    _defineProperty(this, \"unserialize\", mol => {\n      if (mol.version.split('.')[0] !== SCHEMA_VERSION.split('.')[0]) throw new Error('Incompatible version');\n      _classPrivateFieldGet(this, _state).idIndex = mol.idIndex;\n      _classPrivateFieldGet(this, _state).rawText = mol.fromText;\n      _classPrivateFieldGet(this, _state).bonds = mol.bonds;\n\n      for (let i in mol.children) {\n        if (mol.children[i].type === Types.element[0]) {\n          let elProps = _objectSpread({}, mol.children[i]);\n\n          delete elProps.type;\n          delete elProps.element;\n          let el = this.createElement(mol.children[i].element, elProps);\n          this.append(el);\n        } else if (Types.subgroup.indexOf(mol.children[i].type) !== -1) {\n          let groupProps = _objectSpread({}, mol.children[i]);\n\n          delete groupProps.children;\n          delete groupProps.type;\n          let group = this.createSubgroup([], groupProps);\n          group.unserialize(mol.children[i].children || []);\n          this.append(group);\n        }\n      }\n    });\n\n    _defineProperty(this, \"createElement\", (element, options) => new Element(element, _objectSpread({}, options, {\n      molecule: this,\n      id: _classPrivateFieldGet(this, _createId).call(this)\n    })));\n\n    _defineProperty(this, \"createElements\", (element, options) => {\n      let count = options.count,\n          bond = options.bond;\n      count = count || 1;\n      delete options.count;\n      delete options.bond;\n      let el = [];\n\n      for (let i = 0; i < count; i += 1) {\n        el.push(this.createElement(element, options));\n        if (bond && i !== 0) this.createBond(el[i], el[i - 1], bond);\n      }\n\n      return el;\n    });\n\n    _defineProperty(this, \"createSubgroup\", (constituents, options) => new Subgroup(constituents, _objectSpread({}, options, {\n      molecule: this,\n      id: _classPrivateFieldGet(this, _createId).call(this)\n    })));\n\n    _defineProperty(this, \"createSubgroups\", options => {\n      let count = options.count;\n      count = count || 1;\n      delete options.count;\n      let sg = [];\n\n      for (let i = 0; i < count; i += 1) {\n        sg.push(this.createSubgroup([], options));\n      }\n\n      return sg;\n    });\n\n    _defineProperty(this, \"createBond\", (one, two, options) => {\n      if (!one || !two) throw new Error('Missing bonding elements');\n      let bondId = (one.id || one) + '-' + (two.id || two);\n      let bondMirror = (two.id || two) + '-' + (one.id || one);\n      options = _objectSpread({\n        bondCount: 1\n      }, options);\n      _classPrivateFieldGet(this, _state).bonds[bondId] = options;\n      _classPrivateFieldGet(this, _state).bonds[bondMirror] = bondId;\n    });\n\n    _defineProperty(this, \"removeBond\", (one, two) => {\n      let bondId = (one.id || one) + '-' + (two.id || two);\n      let bondMirror = (two.id || two) + '-' + (one.id || one);\n      delete _classPrivateFieldGet(this, _state).bonds[bondId];\n      delete _classPrivateFieldGet(this, _state).bonds[bondMirror];\n    });\n\n    _defineProperty(this, \"getBond\", (one, two) => {\n      let bondId = (one.id || one) + '-' + (two.id || two);\n\n      if (!_classPrivateFieldGet(this, _state).bonds[bondId]) {\n        return null;\n      } else if (typeof _classPrivateFieldGet(this, _state).bonds[bondId] === 'string') {\n        return _classPrivateFieldGet(this, _state).bonds[_classPrivateFieldGet(this, _state).bonds[bondId]];\n      } else {\n        return _classPrivateFieldGet(this, _state).bonds[bondId];\n      }\n    });\n\n    _defineProperty(this, \"getBonds\", one => {\n      let bondPart = one.id || one;\n      let bonds = [];\n\n      for (let i in _classPrivateFieldGet(this, _state).bonds) {\n        if (i.split('-')[0] === bondPart) bonds.push(i);\n      }\n\n      return bonds;\n    });\n\n    _defineProperty(this, \"append\", Collection.append.bind(_classPrivateFieldGet(this, _state)));\n\n    _defineProperty(this, \"appendAll\", Collection.appendAll.bind(_classPrivateFieldGet(this, _state)));\n\n    _defineProperty(this, \"getElementFraction\", Collection.getElementFraction.bind(_classPrivateFieldGet(this, _state)));\n\n    _defineProperty(this, \"getMassFraction\", Collection.getMassFraction.bind(_classPrivateFieldGet(this, _state)));\n\n    _defineProperty(this, \"parse\", () => {\n      let _classPrivateFieldGet2 = _classPrivateFieldGet(this, _state),\n          rawText = _classPrivateFieldGet2.rawText,\n          format = _classPrivateFieldGet2.format;\n\n      if (format === _classPrivateFieldGet(this, _state).formats[0]) {\n        _classPrivateFieldGet(this, _state).children = Basic.call(this, rawText);\n      } else if (format === _classPrivateFieldGet(this, _state).formats[1]) {\n        Iupac.call(this, rawText);\n      } else if (typeof _classPrivateFieldGet(this, _state).options.parsers[format] === 'function') {\n        _classPrivateFieldGet(this, _state).children = _classPrivateFieldGet(this, _state).options.parsers[format].call(this, rawText);\n      } else {\n        throw new Error(`Cannot parse type \"${format}\".`);\n      }\n    });\n\n    for (let i in _options.parsers) {\n      _classPrivateFieldGet(this, _state).formats.push(i);\n    }\n\n    const fromText = typeof _rawText === 'string';\n\n    if (fromText && _classPrivateFieldGet(this, _state).formats.indexOf(_format) === -1) {\n      throw new Error(`Text to parse and format must be specified.`);\n    }\n\n    _classPrivateFieldSet(this, _state, _objectSpread({}, _classPrivateFieldGet(this, _state), {}, {\n      rawText: _rawText,\n      format: _format,\n      parent,\n      options: _objectSpread({}, {}, {}, _options)\n    }));\n\n    if (fromText) this.parse();\n  }\n\n  get children() {\n    return Array.prototype.slice.call(_classPrivateFieldGet(this, _state).children);\n  }\n\n  get type() {\n    return _classPrivateFieldGet(this, _state).type;\n  }\n\n  get version() {\n    return SCHEMA_VERSION;\n  }\n\n  get mass() {\n    return Collection.getMass.call(_classPrivateFieldGet(this, _state));\n  }\n\n  get counts() {\n    return Collection.getCounts.call(_classPrivateFieldGet(this, _state));\n  }\n\n  get childIds() {\n    return Collection.getChildIds.call(_classPrivateFieldGet(this, _state));\n  }\n\n}\n\nvar _state = new WeakMap();\n\nvar _createId = new WeakMap();\n\nmodule.exports = Molecule;","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst Parser = require('rd-parse');\n\nconst Y = require('./../shared/combinator');\n\nconst ConvertToAtomic = require('./../shared/convertToAtomic');\n\nconst BasicGrammar = function BasicGrammar(Token, All, Any, Plus, Optional, Node) {\n  const Molecule = this;\n  return Y(function (ThisGrammar) {\n    Token(/\\s+/g, 'ignore');\n    Token(/([()\\][^_])/g, 'verbatim');\n    const ElementToken = Token(/([A-Z][a-z]*)/g, 'element');\n    const Count = Token(/([0-9]+)/g, 'count');\n    const Charge = Token(/([+-]?[0-9]+)/g, 'charge');\n    const ChargeNode = Node(All('^', Charge), charge => Number(charge) && Number(charge) !== 0 ? {\n      charge: Number(charge)\n    } : {});\n    const CountNode = Node(All(Count), count => Number(count) && Number(count) !== 1 ? {\n      count: Number(count)\n    } : {});\n    const Suffix = Node(Any(All(Optional('_'), CountNode, ChargeNode), All(ChargeNode, '_', CountNode), ChargeNode, All(Optional('_'), CountNode)), stack => stack || []);\n    const ParentheticalGroup = Node(All('(', ThisGrammar, ')', Optional(Suffix)), ([subgroup, suffix]) => {\n      let opts = {};\n      suffix = suffix || [];\n\n      for (let i in suffix) {\n        opts = _objectSpread({}, opts, {}, suffix[i]);\n      }\n\n      return Molecule.createSubgroup(subgroup, opts);\n    });\n    const ComplexGroup = Node(All('[', ThisGrammar, ']', Optional(Suffix)), ([subgroup, suffix]) => {\n      let opts = {\n        type: 'complex'\n      };\n      suffix = suffix || [];\n\n      for (let i in suffix) {\n        opts = _objectSpread({}, opts, {}, suffix[i]);\n      }\n\n      return Molecule.createSubgroup(subgroup, opts);\n    });\n    const FreeElement = Node(All(ElementToken, Optional(Suffix)), ([symbol, suffix]) => {\n      let opts = {};\n      suffix = suffix || [];\n\n      for (let i in suffix) {\n        opts = _objectSpread({}, opts, {}, suffix[i]);\n      }\n\n      return Molecule.createElement(ConvertToAtomic(symbol), opts);\n    });\n    return Node(Plus(Any(FreeElement, ParentheticalGroup, ComplexGroup)), stack => stack);\n  });\n};\n\nmodule.exports = function (text) {\n  return new Parser(BasicGrammar.bind(this)).parse(text);\n};","const AtomicToSymbol = require('./../maps/atomicToSymbol.json');\n\nconst SymbolToAtomic = {};\n\nfor (let i in AtomicToSymbol) {\n  SymbolToAtomic[AtomicToSymbol[i]] = Number(i) + 1;\n}\n\nmodule.exports = symbol => {\n  if (SymbolToAtomic.hasOwnProperty(symbol)) return SymbolToAtomic[symbol];\n  throw new Error(`Unable to resolve \"${symbol}\" to an atomic number.`);\n};","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst Parser = require('rd-parse');\n\nconst Y = require('../shared/combinator');\n\nconst HydrocarbonPrefix = require('./../maps/hydrocarbonPrefix.json');\n\nconst FunctionalGroups = require('./../maps/functionalGroups.json');\n\nconst GreekCounts = require('./../maps/greekCounts.json');\n\nconst IupacGrammar = function IupacGrammar(Token, All, Any, Plus, Optional, Node) {\n  const Molecule = this;\n  return Y(function (ThisGrammar) {\n    Token(/\\s+/g, 'ignore'); // Ignore whitespace\n\n    Token(/([(),-])/g, 'verbatim'); // Assistive characters\n\n    /** ex. meth, eth, prop, ... */\n\n    const PrefixNode = Node(Token(new RegExp(`(${HydrocarbonPrefix.join('|')})(?!yl)`, 'g'), 'prefix'), ([prefix]) => ({\n      prefix: Number(HydrocarbonPrefix.indexOf(prefix)) + 1\n    }));\n    /** ex. ane, ene, an (depending upon context) ... */\n\n    const BondCountNode = Node(Token(/(ane?|ene?|yne?)/g, 'bondCount'), ([bondCount]) => ({\n      bondCount: bondCount[0] === 'a' ? 1 : bondCount[0] === 'e' ? 2 : 3\n    }));\n    /** ex. cyclo */\n\n    const CyclicNode = Node(Token(/(cyclo)/g, 'cyclic'), () => ({\n      cyclic: true\n    }));\n    /** ex. acid */\n\n    const AcidNode = Node(Token(/(\\sacid)/g, 'acid'), () => ({\n      acid: true\n    }));\n    /** ex. 1 */\n\n    const LocationNode = Node(Token(/([0-9]+)/g, 'location'), ([location]) => location);\n    /** ex. fluoro */\n\n    const PreFunctionalNode = Node(Token(new RegExp(`(${Object.keys(FunctionalGroups).filter(group => !!FunctionalGroups[group].pre).join('|')})`, 'g'), 'prefn'), ([fn]) => ({\n      fn\n    }));\n    /** ex. ol */\n\n    const PostFunctionalNode = Node(Token(new RegExp(`(${Object.keys(FunctionalGroups).filter(group => !FunctionalGroups[group].pre).join('|')})`, 'g'), 'postfn'), ([fn]) => ({\n      fn\n    }));\n    /** ex. di, tri */\n\n    const GreekCount = Node(Token(new RegExp(`(${GreekCounts.join('|')})`, 'g'), 'greekCount'), ([groupCount]) => ({\n      count: Number(GreekCounts.indexOf(groupCount)) + 1\n    }));\n    /** ex. -1,2,3- or -1,2,3,- */\n\n    const LocationGroup = Node(All(Optional('-'), LocationNode, Optional(Plus(All(',', LocationNode))), Optional(','), '-'), location => {\n      for (let i in location) location[i] = Number(location[i]);\n\n      return {\n        location\n      };\n    });\n\n    const FunctionalHandler = groups => {\n      let options = {\n        type: 'fngroup',\n        location: []\n      };\n\n      for (let i in groups) {\n        if (groups[i].hasOwnProperty('location')) {\n          options.location = options.location.concat(groups[i].location);\n          continue;\n        }\n\n        options = _objectSpread({}, options, {}, groups[i]);\n      }\n\n      while (options.location.length < (options.count || 1)) options.location.push(-1);\n\n      let fngroups = [];\n\n      for (let i in options.location) {\n        fngroups.push(_objectSpread({}, options, {\n          location: options.location[i],\n          count: 1\n        }));\n      }\n\n      return {\n        fngroups\n      };\n    };\n    /** ex. 2,3-difluoro */\n\n\n    const PreFunctionalGroup = Node(All(Optional(LocationGroup), Optional(GreekCount), PreFunctionalNode), FunctionalHandler);\n    /** ex. -1,2-diol */\n\n    const PostFunctionalGroup = Node(All(Optional(LocationGroup), Optional(GreekCount), PostFunctionalNode), FunctionalHandler);\n    const FreeChain = Node(All( // 1,2,2-trichloro-\n    Optional(Plus(PreFunctionalGroup)), // -1,2- (can be either at start or middle)\n    Optional(LocationGroup), // cyclo-\n    Optional(CyclicNode), // but-\n    PrefixNode, // -1,2- (denotes same thing as first one)\n    Optional(LocationGroup), // -ane, -ene, -yne\n    BondCountNode, // -1,2-diol\n    Optional(Plus(PostFunctionalGroup)), // acid\n    Optional(AcidNode)), groups => {\n      // All props\n      let chainProps = {\n        location: [],\n        children: []\n      };\n\n      for (let i in groups) {\n        if (groups[i].hasOwnProperty('fngroups')) {\n          chainProps.children = chainProps.children.concat(groups[i].fngroups);\n          continue;\n        }\n\n        chainProps = _objectSpread({}, chainProps, {}, groups[i]);\n      } // Generate carbons in main chain\n\n\n      let carbons = Molecule.createElements(6, {\n        count: chainProps.prefix,\n        chain: true,\n        bond: {\n          bondCount: 1\n        }\n      });\n      let carbonIds = [];\n\n      for (let i in carbons) carbonIds.push(carbons[i].id); // Generate child functional groups\n\n\n      let chainChildren = carbons.slice();\n      let implicitChildren = [];\n\n      for (let i in chainProps.children) {\n        let location = chainProps.children[i].location;\n        delete chainProps.children[i].location;\n        let group = Molecule.createSubgroup([], chainProps.children[i]);\n        group.unserialize(FunctionalGroups[chainProps.children[i].fn].members);\n\n        if (location === -1) {\n          implicitChildren.push(group);\n        } else {\n          for (let o in group.children) {\n            let bond = (FunctionalGroups[chainProps.children[i].fn].bonds || [])[o] || {};\n            Molecule.createBond(carbonIds[location - 1], group.children[o].id, bond);\n          }\n        }\n\n        chainChildren.push(group);\n      }\n\n      delete chainProps.children; // Generate the main chain group\n\n      let chain = Molecule.createSubgroup(chainChildren, _objectSpread({\n        type: 'chain'\n      }, chainProps)); // ethene, ethyne, propene, propyne can be implicitly at location 1\n\n      if (chainProps.bondCount !== 1 && chainProps.location.length === 0 && (chainProps.prefix === 2 || chainProps.prefix === 3)) chainProps.location.push(1); // Change bond counts for main chain\n\n      for (let i in chainProps.location) {\n        Molecule.createBond(carbonIds[chainProps.location[i]], carbonIds[chainProps.location[i] - 1], {\n          bondCount: chainProps.bondCount || 1\n        });\n      } // Append the chain\n\n\n      Molecule.append(chain); // Fix implicitly bonded functional groups (e.g. trichloroethene)\n\n      for (let i in carbons) {\n        if (!implicitChildren[0]) break;\n        let bondCount = 0;\n        let bonds = Molecule.getBonds(carbons[i]);\n\n        for (let o in bonds) {\n          let bond = Molecule.getBond(carbons[i], bonds[o].split('-')[1]);\n          bondCount += bond.bondCount;\n        }\n\n        for (let o = bondCount; o < 4; o += 1) {\n          if (!implicitChildren[0]) break;\n\n          for (let u in implicitChildren[0].children) {\n            let bond = (FunctionalGroups[implicitChildren[0].functionalGroup].bonds || [])[u] || {};\n            Molecule.createBond(carbons[i], implicitChildren[0].children[u], bond);\n          }\n\n          implicitChildren = implicitChildren.slice(1);\n        }\n      } // Dynamically add and bond hydrogens to carbon\n\n\n      const flat = Molecule.childIds;\n\n      for (let i in flat) {\n        if (flat[i].element === 6) {\n          let bondCount = 0;\n          let bonds = Molecule.getBonds(flat[i]);\n\n          for (let o in bonds) {\n            let bond = Molecule.getBond(i, bonds[o].split('-')[1]);\n            bondCount += bond.bondCount;\n          }\n\n          for (let o = bondCount; o < 4; o += 1) {\n            let el = Molecule.createElement(1);\n            flat[i].parent.append(el);\n            Molecule.createBond(flat[i], el);\n          }\n        }\n      }\n\n      return chain;\n    });\n    return Node(Plus(Any(FreeChain)), stack => stack);\n  });\n};\n\nmodule.exports = function (text) {\n  return new Parser(IupacGrammar.bind(this)).parse(text);\n};","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to get private field on non-instance\"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nconst AtomicToSymbol = require('./maps/atomicToSymbol.json');\n\nconst AtomicToName = require('./maps/atomicToName.json');\n\nconst AtomicToAMU = require('./maps/atomicToAMU.json');\n\nconst Collection = require('./shared/Collection');\n\nclass Element {\n  constructor(atomicNumber, _ref) {\n    let count = _ref.count,\n        charge = _ref.charge,\n        id = _ref.id,\n        molecule = _ref.molecule,\n        _meta = _objectWithoutProperties(_ref, [\"count\", \"charge\", \"id\", \"molecule\"]);\n\n    _state.set(this, {\n      writable: true,\n      value: {\n        el: 1,\n        id: '',\n        molecule: null,\n        meta: {\n          count: 1,\n          charge: 0\n        }\n      }\n    });\n\n    _defineProperty(this, \"serialize\", () => {\n      let meta = _objectSpread({}, _classPrivateFieldGet(this, _state).meta);\n\n      if (meta.charge === 0) delete meta.charge;\n      if (meta.count === 1) delete meta.count;\n      return _objectSpread({\n        type: 'element',\n        element: _classPrivateFieldGet(this, _state).el,\n        id: _classPrivateFieldGet(this, _state).id\n      }, Object.keys(meta).length === 0 ? {} : meta);\n    });\n\n    _defineProperty(this, \"type\", 'element');\n\n    _defineProperty(this, \"set\", (key, value) => {\n      if (key === 'count' && (isNaN(value) || !Number.isInteger(value) || value === 0)) return;\n      if (key === 'charge' && (isNaN(value) || !Number.isInteger(value))) return;\n      _classPrivateFieldGet(this, _state).meta = _objectSpread({}, _classPrivateFieldGet(this, _state).meta, {\n        [key]: value\n      });\n    });\n\n    _classPrivateFieldGet(this, _state).el = Number(atomicNumber);\n    this.set('count', count);\n    this.set('charge', charge);\n    _classPrivateFieldGet(this, _state).id = id;\n    _classPrivateFieldGet(this, _state).molecule = molecule;\n    _classPrivateFieldGet(this, _state).meta = _objectSpread({}, _classPrivateFieldGet(this, _state).meta, {}, _meta);\n  }\n\n  get element() {\n    return _classPrivateFieldGet(this, _state).el;\n  }\n\n  get symbol() {\n    return AtomicToSymbol[_classPrivateFieldGet(this, _state).el - 1];\n  }\n\n  get name() {\n    return AtomicToName[_classPrivateFieldGet(this, _state).el - 1];\n  }\n\n  get mass() {\n    return AtomicToAMU[_classPrivateFieldGet(this, _state).el - 1] * _classPrivateFieldGet(this, _state).meta.count;\n  }\n\n  get count() {\n    return _classPrivateFieldGet(this, _state).meta.count;\n  }\n\n  get charge() {\n    return _classPrivateFieldGet(this, _state).meta.charge;\n  }\n\n  get parent() {\n    return Collection.getParent.call(_classPrivateFieldGet(this, _state));\n  }\n\n  get id() {\n    return _classPrivateFieldGet(this, _state).id;\n  }\n\n}\n\nvar _state = new WeakMap();\n\nmodule.exports = Element;","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to get private field on non-instance\"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nconst Collection = require('./shared/Collection');\n\nconst Types = require('./shared/types');\n\nclass Subgroup {\n  constructor(_children, _ref) {\n    let _type = _ref.type,\n        count = _ref.count,\n        charge = _ref.charge,\n        id = _ref.id,\n        molecule = _ref.molecule,\n        _meta = _objectWithoutProperties(_ref, [\"type\", \"count\", \"charge\", \"id\", \"molecule\"]);\n\n    _state.set(this, {\n      writable: true,\n      value: {\n        children: [],\n        type: 'subgroup',\n        id: '',\n        meta: {\n          count: 1,\n          charge: 0\n        }\n      }\n    });\n\n    _defineProperty(this, \"findById\", Collection.findById.bind(_classPrivateFieldGet(this, _state), this));\n\n    _defineProperty(this, \"serialize\", () => {\n      let children = Array.prototype.slice.call(_classPrivateFieldGet(this, _state).children);\n\n      let meta = _objectSpread({}, _classPrivateFieldGet(this, _state).meta);\n\n      for (let i in children) {\n        if (typeof children[i].serialize === 'function') {\n          children[i] = children[i].serialize();\n        }\n      }\n\n      if (meta.charge === 0) delete meta.charge;\n      if (meta.count === 1) delete meta.count;\n      return _objectSpread({\n        type: _classPrivateFieldGet(this, _state).type,\n        children,\n        id: _classPrivateFieldGet(this, _state).id\n      }, Object.keys(meta).length === 0 ? {} : meta);\n    });\n\n    _defineProperty(this, \"unserialize\", mol => {\n      for (let i in mol) {\n        if (mol[i].type === 'element') {\n          let elProps = _objectSpread({}, mol[i]);\n\n          delete elProps.type;\n          delete elProps.element;\n\n          let el = _classPrivateFieldGet(this, _state).molecule.createElement(mol[i].element, elProps); //test\n\n\n          this.append(el);\n        } else if (Types.subgroup.indexOf(mol[i].type) !== -1) {\n          let groupProps = _objectSpread({}, mol[i]);\n\n          delete groupProps.children;\n          delete groupProps.type;\n\n          let group = _classPrivateFieldGet(this, _state).molecule.createSubgroup([], groupProps);\n\n          group.unserialize(mol[i].children || []);\n          this.append(group);\n        }\n      }\n    });\n\n    _defineProperty(this, \"setType\", type => {\n      if (Types.subgroup.indexOf(type) !== -1) {\n        _classPrivateFieldGet(this, _state).type = type;\n      } else if (type) {\n        throw new Error(`Invalid subgroup type: ${type}`);\n      }\n    });\n\n    _defineProperty(this, \"set\", (key, value) => {\n      if (key === 'count' && (isNaN(value) || !Number.isInteger(value) || value === 0)) return;\n      if (key === 'charge' && (isNaN(value) || !Number.isInteger(value))) return;\n      _classPrivateFieldGet(this, _state).meta = _objectSpread({}, _classPrivateFieldGet(this, _state).meta, {\n        [key]: value\n      });\n    });\n\n    _defineProperty(this, \"append\", Collection.append.bind(_classPrivateFieldGet(this, _state)));\n\n    _defineProperty(this, \"appendAll\", Collection.appendAll.bind(_classPrivateFieldGet(this, _state)));\n\n    this.setType(_type);\n    _classPrivateFieldGet(this, _state).id = id;\n    _classPrivateFieldGet(this, _state).molecule = molecule;\n    this.set('count', count);\n    this.set('charge', charge);\n\n    for (let i in _meta) this.set(i, _meta[i]);\n\n    for (let i in _children) {\n      if (Array.isArray(_children[i])) {\n        _classPrivateFieldGet(this, _state).children = _classPrivateFieldGet(this, _state).children.concat(_children[i]);\n      } else {\n        _classPrivateFieldGet(this, _state).children.push(_children[i]);\n      }\n    }\n  }\n\n  get id() {\n    return _classPrivateFieldGet(this, _state).id;\n  }\n\n  get type() {\n    return _classPrivateFieldGet(this, _state).type;\n  }\n\n  get children() {\n    return Array.prototype.slice.call(_classPrivateFieldGet(this, _state).children);\n  }\n\n  get childIds() {\n    return Collection.getChildIds.call(_classPrivateFieldGet(this, _state));\n  }\n\n  get counts() {\n    return Collection.getCounts.call(_classPrivateFieldGet(this, _state));\n  }\n\n  get count() {\n    return _classPrivateFieldGet(this, _state).meta.count;\n  }\n\n  get charge() {\n    return _classPrivateFieldGet(this, _state).meta.charge;\n  }\n\n  get functionalGroup() {\n    return _classPrivateFieldGet(this, _state).meta.fn;\n  }\n\n  get mass() {\n    return Collection.getMass.call(_classPrivateFieldGet(this, _state));\n  }\n\n  get parent() {\n    return Collection.getParent.call(_classPrivateFieldGet(this, _state));\n  }\n\n}\n\nvar _state = new WeakMap();\n\nmodule.exports = Subgroup;"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC9PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACxOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A","sourceRoot":""}