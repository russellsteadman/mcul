{"version":3,"file":"mcul.node.js","sources":["webpack:///webpack/bootstrap","webpack:///../src/shared/combinator.js","webpack:///../src/shared/mol/recursiveCount.js","webpack:///../src/shared/mol/findById.js","webpack:///../src/mcul.js","webpack:///../src/Molecule.js","webpack:///../src/parsers/basic.js","webpack:///../src/shared/convertToAtomic.js","webpack:///../src/parsers/iupac.js","webpack:///../src/shared/mol/elementFraction.js","webpack:///../src/Element.js","webpack:///../src/Subgroup.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","module.exports = function (gen) {\n  return function (f) {\n    return f(f);\n  }(function (f) {\n    return gen(function () {\n      return f(f).apply(null, arguments);\n    });\n  });\n};","const RecursiveCount = parsed => {\n  let counts = {};\n\n  for (let i in parsed) {\n    if (parsed[i].type === 'element') {\n      counts[parsed[i].element] = isNaN(counts[parsed[i].element]) ? parsed[i].count || 1 : (parsed[i].count || 1) * counts[parsed[i].element];\n    } else {\n      let groupCount = RecursiveCount(parsed[i].children);\n\n      for (let o in groupCount) {\n        if (parsed[i].count) groupCount[o] *= parsed[i].count;\n        counts[o] = isNaN(counts[o]) ? groupCount[o] || 0 : (groupCount[o] || 0) + counts[o];\n      }\n    }\n  }\n\n  return counts;\n};\n\nmodule.exports = RecursiveCount;","module.exports = (id, members) => {\n  for (let i in members) {\n    if (members[i].id === id) return members[i];\n\n    if (typeof members[i].findById === 'function') {\n      let subsearch = members[i].findById(id);\n      if (subsearch) return subsearch;\n    }\n  }\n\n  return null;\n};","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to get private field on non-instance\"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nconst Molecule = require('./Molecule');\n\nclass Generator {\n  constructor() {\n    _state.set(this, {\n      writable: true,\n      value: {\n        parsers: {},\n        defaultFormat: 'basic'\n      }\n    });\n\n    _defineProperty(this, \"create\", options => {\n      return new Molecule(_objectSpread({}, options, {\n        parsers: _classPrivateFieldGet(this, _state).parsers,\n        parent: this\n      }));\n    });\n\n    _defineProperty(this, \"createFromText\", (rawText, format, options) => {\n      if (!format) format = _classPrivateFieldGet(this, _state).defaultFormat;\n      return new Molecule(_objectSpread({}, options, {\n        parsers: _classPrivateFieldGet(this, _state).parsers,\n        rawText,\n        format,\n        parent: this\n      }));\n    });\n\n    _defineProperty(this, \"setDefaultFormat\", format => {\n      _classPrivateFieldGet(this, _state).defaultFormat = format;\n    });\n\n    _defineProperty(this, \"addParser\", (parser, format) => {\n      if (typeof parser !== 'function' && typeof format !== 'string') {\n        throw new Error('Parser and format must be specified.');\n      }\n\n      _classPrivateFieldGet(this, _state).parsers[format] = parser;\n    });\n  }\n\n}\n\nvar _state = new WeakMap();\n\nmodule.exports = new Generator();","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to set private field on non-instance\"); } if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError(\"attempted to set read only private field\"); } descriptor.value = value; } return value; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to get private field on non-instance\"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nconst Basic = require('./parsers/basic');\n\nconst Iupac = require('./parsers/iupac');\n\nconst RecursiveCount = require('./shared/mol/recursiveCount');\n\nconst ElementFraction = require('./shared/mol/elementFraction');\n\nconst FindById = require('./shared/mol/findById');\n\nconst Element = require('./Element');\n\nconst Subgroup = require('./Subgroup');\n\nconst SCHEMA_VERSION = '0.1.0';\n\nclass Molecule {\n  constructor(_ref) {\n    let _rawText = _ref.rawText,\n        _format = _ref.format,\n        _options = _objectWithoutProperties(_ref, [\"rawText\", \"format\"]);\n\n    _formats.set(this, {\n      writable: true,\n      value: ['basic', 'iupac']\n    });\n\n    _state.set(this, {\n      writable: true,\n      value: {\n        children: [],\n        idIndex: 0\n      }\n    });\n\n    _defineProperty(this, \"version\", SCHEMA_VERSION);\n\n    _defineProperty(this, \"type\", 'molecule');\n\n    _createId.set(this, {\n      writable: true,\n      value: () => {\n        _classPrivateFieldGet(this, _state).idIndex += 1;\n        return _classPrivateFieldGet(this, _state).idIndex.toString(36);\n      }\n    });\n\n    _defineProperty(this, \"findById\", id => {\n      if (id === false) return this;\n      return FindById(id, _classPrivateFieldGet(this, _state).children);\n    });\n\n    _defineProperty(this, \"serialize\", () => {\n      let children = Array.prototype.slice.call(_classPrivateFieldGet(this, _state).children);\n\n      for (let i in children) {\n        if (typeof children[i].serialize === 'function') {\n          children[i] = children[i].serialize();\n        }\n      }\n\n      return _objectSpread({\n        type: 'molecule',\n        version: SCHEMA_VERSION,\n        children,\n        idIndex: _classPrivateFieldGet(this, _state).idIndex\n      }, _classPrivateFieldGet(this, _state).rawText ? {\n        fromText: _classPrivateFieldGet(this, _state).rawText\n      } : {});\n    });\n\n    _defineProperty(this, \"unserialize\", text => {\n      let mol = JSON.parse(text);\n      if (mol.version.split('.')[0] !== SCHEMA_VERSION.split('.')[0]) throw new Error('Incompatible version');\n      _classPrivateFieldGet(this, _state).idIndex = mol.idIndex;\n      _classPrivateFieldGet(this, _state).rawText = mol.fromText;\n\n      for (let i in mol.children) {\n        if (mol.children[i].type === 'element') {\n          let elProps = _objectSpread({}, mol.children[i]);\n\n          delete elProps.type;\n          delete elProps.element;\n          let el = this.createElement(mol.children[i].element, elProps);\n          this.append(el);\n        } else if (['subgroup', 'complex', 'fngroup', 'chain'].indexOf(mol.children[i].type) !== -1) {\n          let groupProps = _objectSpread({}, mol.children[i]);\n\n          delete groupProps.children;\n          delete groupProps.type;\n          let group = this.createSubgroup([], groupProps);\n          group.unserialize(mol.children[i].children || []);\n          this.append(group);\n        }\n      }\n    });\n\n    _defineProperty(this, \"createElement\", (element, options) => new Element(element, _objectSpread({}, options, {\n      molecule: this,\n      id: _classPrivateFieldGet(this, _createId).call(this)\n    })));\n\n    _defineProperty(this, \"createSubgroup\", (constituents, options) => new Subgroup(constituents, _objectSpread({}, options, {\n      molecule: this,\n      id: _classPrivateFieldGet(this, _createId).call(this)\n    })));\n\n    _defineProperty(this, \"append\", item => {\n      const types = ['element', 'subgroup', 'complex', 'fngroup', 'chain'];\n      if (!item || types.indexOf(item.type) === -1) throw new Error('Cannot append invalid item');\n\n      _classPrivateFieldGet(this, _state).children.push(item);\n    });\n\n    _defineProperty(this, \"getCounts\", () => RecursiveCount(_classPrivateFieldGet(this, _state).children));\n\n    _defineProperty(this, \"getCount\", element => RecursiveCount(_classPrivateFieldGet(this, _state).children)[element] || 0);\n\n    _defineProperty(this, \"getElementFraction\", element => ElementFraction(_classPrivateFieldGet(this, _state).children, element));\n\n    _defineProperty(this, \"parse\", () => {\n      let _classPrivateFieldGet2 = _classPrivateFieldGet(this, _state),\n          rawText = _classPrivateFieldGet2.rawText,\n          format = _classPrivateFieldGet2.format;\n\n      if (format === _classPrivateFieldGet(this, _formats)[0]) {\n        _classPrivateFieldGet(this, _state).children = Basic.call(this, rawText);\n      } else if (format === _classPrivateFieldGet(this, _formats)[1]) {\n        _classPrivateFieldGet(this, _state).children = Iupac.call(this, rawText);\n      } else if (typeof _classPrivateFieldGet(this, _state).options.parsers[format] === 'function') {\n        _classPrivateFieldGet(this, _state).children = _classPrivateFieldGet(this, _state).options.parsers[format].call(this, rawText);\n      } else {\n        throw new Error(`Cannot parse type \"${format}\".`);\n      }\n    });\n\n    for (let i in _options.parsers) {\n      _classPrivateFieldGet(this, _formats).push(i);\n    }\n\n    const fromText = typeof _rawText === 'string';\n\n    if (fromText && _classPrivateFieldGet(this, _formats).indexOf(_format) === -1) {\n      throw new Error(`Text to parse and format must be specified.`);\n    }\n\n    _classPrivateFieldSet(this, _state, _objectSpread({}, _classPrivateFieldGet(this, _state), {}, {\n      rawText: _rawText,\n      format: _format,\n      options: _objectSpread({}, {}, {}, _options)\n    }));\n\n    if (fromText) this.parse();\n  }\n\n  get children() {\n    return Array.prototype.slice.call(_classPrivateFieldGet(this, _state).children);\n  }\n\n  get mass() {\n    let sum = 0;\n\n    for (let i in _classPrivateFieldGet(this, _state).children) {\n      sum += _classPrivateFieldGet(this, _state).children[i].mass;\n    }\n\n    return Math.round(sum * 1000) / 1000;\n  }\n\n  get childIds() {\n    let ids = {};\n\n    for (let i in _classPrivateFieldGet(this, _state).children) {\n      ids[_classPrivateFieldGet(this, _state).children[i].id] = false;\n\n      if (_classPrivateFieldGet(this, _state).children[i].childIds) {\n        ids = _objectSpread({}, ids, {}, _classPrivateFieldGet(this, _state).children[i].childIds);\n      }\n    }\n\n    return ids;\n  }\n\n}\n\nvar _formats = new WeakMap();\n\nvar _state = new WeakMap();\n\nvar _createId = new WeakMap();\n\nmodule.exports = Molecule;","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst Parser = require('rd-parse');\n\nconst Y = require('./../shared/combinator');\n\nconst ConvertToAtomic = require('./../shared/convertToAtomic');\n\nconst BasicGrammar = function BasicGrammar(Token, All, Any, Plus, Optional, Node) {\n  const Molecule = this;\n  return Y(function (ThisGrammar) {\n    Token(/\\s+/g, 'ignore');\n    Token(/([()\\][^_])/g, 'verbatim');\n    const ElementToken = Token(/([A-Z][a-z]*)/g, 'element');\n    const Count = Token(/([0-9]+)/g, 'count');\n    const Charge = Token(/([+-]?[0-9]+)/g, 'charge');\n    const ChargeNode = Node(All('^', Charge), charge => Number(charge) && Number(charge) !== 0 ? {\n      charge: Number(charge)\n    } : {});\n    const CountNode = Node(All(Count), count => Number(count) && Number(count) !== 1 ? {\n      count: Number(count)\n    } : {});\n    const Suffix = Node(Any(All(Optional('_'), CountNode, ChargeNode), All(ChargeNode, '_', CountNode), ChargeNode, All(Optional('_'), CountNode)), stack => stack || []);\n    const ParentheticalGroup = Node(All('(', ThisGrammar, ')', Optional(Suffix)), ([subgroup, suffix]) => Molecule.createSubgroup(subgroup, (suffix || []).reduce((a, b) => {\n      a = _objectSpread({}, a, {}, b);\n      return a;\n    }, {})));\n    const ComplexGroup = Node(All('[', ThisGrammar, ']', Optional(Suffix)), ([subgroup, suffix]) => Molecule.createSubgroup(subgroup, (suffix || []).reduce((a, b) => {\n      a = _objectSpread({}, a, {}, b);\n      return a;\n    }, {\n      type: 'complex'\n    })));\n    const FreeElement = Node(All(ElementToken, Optional(Suffix)), ([symbol, suffix]) => Molecule.createElement(ConvertToAtomic(symbol), (suffix || []).reduce((a, b) => {\n      a = _objectSpread({}, a, {}, b);\n      return a;\n    }, {})));\n    return Node(Plus(Any(FreeElement, ParentheticalGroup, ComplexGroup)), stack => stack);\n  });\n};\n\nmodule.exports = function (text) {\n  return new Parser(BasicGrammar.bind(this)).parse(text);\n};","const AtomicToSymbol = require('./../maps/atomicToSymbol.json');\n\nconst SymbolToAtomic = AtomicToSymbol.reduce((a, b, c) => {\n  a[b] = Number(c) + 1;\n  return a;\n}, {});\n\nmodule.exports = symbol => {\n  if (SymbolToAtomic.hasOwnProperty(symbol)) return SymbolToAtomic[symbol];\n  throw new Error(`Unable to resolve \"${symbol}\" to an atomic number.`);\n};","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst Parser = require('rd-parse');\n\nconst Y = require('../shared/combinator');\n\nconst HydrocarbonPrefix = require('./../maps/hydrocarbonPrefix.json');\n\nconst FunctionalGroups = require('./../maps/functionalGroups.json');\n\nconst GreekCounts = require('./../maps/greekCounts.json');\n\nconst IupacGrammar = function IupacGrammar(Token, All, Any, Plus, Optional, Node) {\n  const Molecule = this;\n  return Y(function (ThisGrammar) {\n    Token(/\\s+/g, 'ignore'); // Ignore whitespace\n\n    Token(/([(),-])/g, 'verbatim'); // Assistive characters\n\n    /** ex. meth, eth, prop, ... */\n\n    const PrefixNode = Node(Token(new RegExp(`(${HydrocarbonPrefix.join('|')})(?!yl)`, 'g'), 'prefix'), ([prefix]) => ({\n      prefix: Number(HydrocarbonPrefix.indexOf(prefix)) + 1\n    }));\n    /** ex. ane, ene, an (depending upon context) ... */\n\n    const BondCountNode = Node(Token(/(ane?|ene?|yne?)/g, 'bondCount'), ([bondCount]) => ({\n      bondCount: bondCount[0] === 'a' ? 1 : bondCount[0] === 'e' ? 2 : 3\n    }));\n    /** ex. cyclo */\n\n    const CyclicNode = Node(Token(/(cyclo)/g, 'cyclic'), () => ({\n      cyclic: true\n    }));\n    /** ex. 1 */\n\n    const LocationNode = Node(Token(/([0-9]+)/g, 'location'), ([location]) => location);\n    /** ex. fluoro */\n\n    const PreFunctionalNode = Node(Token(new RegExp(`(${Object.keys(FunctionalGroups).filter(group => !!FunctionalGroups[group].pre).join('|')})`, 'g'), 'prefn'), ([fn]) => ({\n      fn\n    }));\n    /** ex. ol */\n\n    const PostFunctionalNode = Node(Token(new RegExp(`(${Object.keys(FunctionalGroups).filter(group => !FunctionalGroups[group].pre).join('|')})`, 'g'), 'postfn'), ([fn]) => ({\n      fn\n    }));\n    /** ex. di, tri */\n\n    const GreekCount = Node(Token(new RegExp(`(${GreekCounts.join('|')})`, 'g'), 'greekCount'), ([groupCount]) => ({\n      count: Number(GreekCounts.indexOf(groupCount)) + 1\n    }));\n    /** ex. -1,2,3- or -1,2,3,- */\n\n    const LocationGroup = Node(All(Optional('-'), LocationNode, Optional(Plus(All(',', LocationNode))), Optional(','), '-'), groups => ({\n      location: groups.reduce((a, b) => {\n        a.push(Number(b));\n        return a;\n      }, [])\n    }));\n    /** ex. 2,3-difluoro */\n\n    const PreFunctionalGroup = Node(All(Optional(LocationGroup), Optional(GreekCount), PreFunctionalNode), groups => {\n      let subgroup = Molecule.createSubgroup([], _objectSpread({\n        type: 'fngroup'\n      }, groups.reduce((a, b) => {\n        if (b.hasOwnProperty('location')) {\n          a.location = a.location.concat(b.location);\n          return a;\n        }\n\n        return _objectSpread({}, a, {}, b);\n      }, {\n        location: []\n      })));\n      subgroup.unserialize(FunctionalGroups[subgroup.functionalGroup].members);\n      return {\n        subgroup\n      };\n    });\n    /** ex. -1,2-diol */\n\n    const PostFunctionalGroup = Node(All(Optional(LocationGroup), Optional(GreekCount), PostFunctionalNode), groups => {\n      let subgroup = Molecule.createSubgroup([], _objectSpread({\n        type: 'fngroup'\n      }, groups.reduce((a, b) => {\n        if (b.hasOwnProperty('location')) {\n          a.location = a.location.concat(b.location);\n          return a;\n        }\n\n        return _objectSpread({}, a, {}, b);\n      }, {\n        location: []\n      })));\n      subgroup.unserialize(FunctionalGroups[subgroup.functionalGroup].members);\n      return {\n        subgroup\n      };\n    });\n    const FreeChain = Node(All( // 1,2,2-trichloro-\n    Optional(Plus(PreFunctionalGroup)), // -1,2- (can be either at start or middle)\n    Optional(LocationGroup), // cyclo-\n    Optional(CyclicNode), // but-\n    PrefixNode, // -1,2- (denotes same thing as first one)\n    Optional(LocationGroup), // -ane, -ene, -yne\n    BondCountNode, // -1,2-diol\n    Optional(Plus(PostFunctionalGroup))), groups => {\n      let chainProps = groups.reduce((a, b) => {\n        if (b.hasOwnProperty('location')) {\n          a.location = a.location.concat(b.location);\n          return a;\n        }\n\n        if (b.hasOwnProperty('subgroup')) {\n          a.children.push(b.subgroup);\n        }\n\n        return _objectSpread({}, a, {}, b);\n      }, {\n        location: [],\n        children: []\n      });\n      let groupCount = chainProps.children.reduce((a, b) => {\n        return a + (b.count || 1);\n      }, 0);\n      let locLength = chainProps.location.length || 1;\n      let chainCount = chainProps.prefix || 1;\n      let bondCount = chainProps.bondCount;\n      let hydrogenCount = chainCount * 2 + 2 - (bondCount - 1) * locLength * 2 - groupCount; // 2 2 0 3\n\n      let chainChildren = chainProps.children.concat([Molecule.createElement(6, {\n        count: chainProps.prefix,\n        chain: true\n      })]);\n      delete chainProps.children;\n      delete chainProps.subgroup;\n      let chain = Molecule.createSubgroup(chainChildren, _objectSpread({\n        type: 'chain'\n      }, chainProps));\n      chain.append(Molecule.createElement(1, {\n        count: hydrogenCount,\n        chain: true\n      }));\n      return chain;\n    });\n    return Node(Plus(Any(FreeChain)), stack => stack);\n  });\n};\n\nmodule.exports = function (text) {\n  return new Parser(IupacGrammar.bind(this)).parse(text);\n};","const RecursiveCount = require('./recursiveCount');\n\nconst Fraction = (parsed, element) => {\n  let counts = RecursiveCount(parsed);\n  let sum = 0;\n\n  for (let i in counts) {\n    sum += counts[i] || 0;\n  }\n\n  return (counts[element] || 0) / sum;\n};\n\nmodule.exports = Fraction;","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to get private field on non-instance\"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nconst AtomicToSymbol = require('./maps/atomicToSymbol.json');\n\nconst AtomicToName = require('./maps/atomicToName.json');\n\nconst AtomicToAMU = require('./maps/atomicToAMU.json');\n\nclass Element {\n  constructor(atomicNumber, _ref) {\n    let count = _ref.count,\n        charge = _ref.charge,\n        id = _ref.id,\n        molecule = _ref.molecule,\n        _meta = _objectWithoutProperties(_ref, [\"count\", \"charge\", \"id\", \"molecule\"]);\n\n    _state.set(this, {\n      writable: true,\n      value: {\n        el: 1,\n        id: '',\n        molecule: null,\n        meta: {\n          count: 1,\n          charge: 0\n        }\n      }\n    });\n\n    _defineProperty(this, \"serialize\", () => {\n      let meta = _objectSpread({}, _classPrivateFieldGet(this, _state).meta);\n\n      if (meta.charge === 0) delete meta.charge;\n      if (meta.count === 1) delete meta.count;\n      return _objectSpread({\n        type: 'element',\n        element: _classPrivateFieldGet(this, _state).el,\n        id: _classPrivateFieldGet(this, _state).id\n      }, Object.keys(meta).length === 0 ? {} : meta);\n    });\n\n    _defineProperty(this, \"type\", 'element');\n\n    _defineProperty(this, \"set\", (key, value) => {\n      if (key === 'count' && (isNaN(value) || !Number.isInteger(value) || value === 0)) return;\n      if (key === 'charge' && (isNaN(value) || !Number.isInteger(value))) return;\n      _classPrivateFieldGet(this, _state).meta = _objectSpread({}, _classPrivateFieldGet(this, _state).meta, {\n        [key]: value\n      });\n    });\n\n    _classPrivateFieldGet(this, _state).el = Number(atomicNumber);\n    this.set('count', count);\n    this.set('charge', charge);\n    _classPrivateFieldGet(this, _state).id = id;\n    _classPrivateFieldGet(this, _state).molecule = molecule;\n    _classPrivateFieldGet(this, _state).meta = _objectSpread({}, _classPrivateFieldGet(this, _state).meta, {}, _meta);\n  }\n\n  get element() {\n    return _classPrivateFieldGet(this, _state).el;\n  }\n\n  get symbol() {\n    return AtomicToSymbol[_classPrivateFieldGet(this, _state).el - 1];\n  }\n\n  get name() {\n    return AtomicToName[_classPrivateFieldGet(this, _state).el - 1];\n  }\n\n  get mass() {\n    return AtomicToAMU[_classPrivateFieldGet(this, _state).el - 1] * _classPrivateFieldGet(this, _state).meta.count;\n  }\n\n  get count() {\n    return _classPrivateFieldGet(this, _state).meta.count;\n  }\n\n  get charge() {\n    return _classPrivateFieldGet(this, _state).meta.charge;\n  }\n\n  get parent() {\n    return _classPrivateFieldGet(this, _state).molecule.findById(_classPrivateFieldGet(this, _state).molecule.childIds[_classPrivateFieldGet(this, _state).id]);\n  }\n\n  get id() {\n    return _classPrivateFieldGet(this, _state).id;\n  }\n\n}\n\nvar _state = new WeakMap();\n\nmodule.exports = Element;","function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError(\"attempted to get private field on non-instance\"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }\n\nconst FindById = require('./shared/mol/findById');\n\nclass Subgroup {\n  constructor(_children, _ref) {\n    let _type = _ref.type,\n        count = _ref.count,\n        charge = _ref.charge,\n        _id = _ref.id,\n        molecule = _ref.molecule,\n        _meta = _objectWithoutProperties(_ref, [\"type\", \"count\", \"charge\", \"id\", \"molecule\"]);\n\n    _state.set(this, {\n      writable: true,\n      value: {\n        children: [],\n        type: 'subgroup',\n        id: '',\n        meta: {\n          count: 1,\n          charge: 0\n        }\n      }\n    });\n\n    _defineProperty(this, \"findById\", id => FindById(id, _classPrivateFieldGet(this, _state).children));\n\n    _defineProperty(this, \"serialize\", () => {\n      let children = Array.prototype.slice.call(_classPrivateFieldGet(this, _state).children);\n\n      let meta = _objectSpread({}, _classPrivateFieldGet(this, _state).meta);\n\n      for (let i in children) {\n        if (typeof children[i].serialize === 'function') {\n          children[i] = children[i].serialize();\n        }\n      }\n\n      if (meta.charge === 0) delete meta.charge;\n      if (meta.count === 1) delete meta.count;\n      return _objectSpread({\n        type: _classPrivateFieldGet(this, _state).type,\n        children,\n        id: _classPrivateFieldGet(this, _state).id\n      }, Object.keys(meta).length === 0 ? {} : meta);\n    });\n\n    _defineProperty(this, \"unserialize\", mol => {\n      for (let i in mol) {\n        if (mol[i].type === 'element') {\n          let elProps = _objectSpread({}, mol[i]);\n\n          delete elProps.type;\n          delete elProps.element;\n\n          let el = _classPrivateFieldGet(this, _state).molecule.createElement(mol[i].element, elProps); //test\n\n\n          this.append(el);\n        } else if (['subgroup', 'complex', 'fngroup', 'chain'].indexOf(mol[i].type) !== -1) {\n          let groupProps = _objectSpread({}, mol[i]);\n\n          delete groupProps.children;\n          delete groupProps.type;\n\n          let group = _classPrivateFieldGet(this, _state).molecule.createSubgroup([], groupProps);\n\n          group.unserialize(mol[i].children || []);\n          this.append(group);\n        }\n      }\n    });\n\n    _defineProperty(this, \"setType\", type => {\n      const types = ['subgroup', 'complex', 'fngroup', 'chain'];\n\n      if (types.indexOf(type) !== -1) {\n        _classPrivateFieldGet(this, _state).type = type;\n      } else if (type) {\n        throw new Error(`Invalid subgroup type: ${type}`);\n      }\n    });\n\n    _defineProperty(this, \"set\", (key, value) => {\n      if (key === 'count' && (isNaN(value) || !Number.isInteger(value) || value === 0)) return;\n      if (key === 'charge' && (isNaN(value) || !Number.isInteger(value))) return;\n      _classPrivateFieldGet(this, _state).meta = _objectSpread({}, _classPrivateFieldGet(this, _state).meta, {\n        [key]: value\n      });\n    });\n\n    _defineProperty(this, \"append\", item => {\n      const types = ['element', 'subgroup', 'complex', 'chain', 'fngroup'];\n      if (!item || types.indexOf(item.type) === -1) throw new Error('Cannot append invalid item');\n\n      _classPrivateFieldGet(this, _state).children.push(item);\n    });\n\n    this.setType(_type);\n    _classPrivateFieldGet(this, _state).id = _id;\n    _classPrivateFieldGet(this, _state).molecule = molecule;\n    this.set('count', count);\n    this.set('charge', charge);\n\n    for (let i in _meta) this.set(i, _meta[i]);\n\n    for (let i in _children) {\n      if (Array.isArray(_children[i])) {\n        _classPrivateFieldGet(this, _state).children = _classPrivateFieldGet(this, _state).children.concat(_children[i]);\n      } else {\n        _classPrivateFieldGet(this, _state).children.push(_children[i]);\n      }\n    }\n  }\n\n  get id() {\n    return _classPrivateFieldGet(this, _state).id;\n  }\n\n  get type() {\n    return _classPrivateFieldGet(this, _state).type;\n  }\n\n  get children() {\n    return Array.prototype.slice.call(_classPrivateFieldGet(this, _state).children);\n  }\n\n  get childIds() {\n    let ids = {};\n\n    for (let i in _classPrivateFieldGet(this, _state).children) {\n      ids[_classPrivateFieldGet(this, _state).children[i].id] = _classPrivateFieldGet(this, _state).id;\n\n      if (_classPrivateFieldGet(this, _state).children[i].childIds) {\n        ids = _objectSpread({}, ids, {}, _classPrivateFieldGet(this, _state).children[i].childIds);\n      }\n    }\n\n    return ids;\n  }\n\n  get count() {\n    return _classPrivateFieldGet(this, _state).meta.count;\n  }\n\n  get charge() {\n    return _classPrivateFieldGet(this, _state).meta.charge;\n  }\n\n  get functionalGroup() {\n    return _classPrivateFieldGet(this, _state).meta.fn;\n  }\n\n  get mass() {\n    let sum = 0;\n\n    for (let i in _classPrivateFieldGet(this, _state).children) {\n      sum += _classPrivateFieldGet(this, _state).children[i].mass;\n    }\n\n    return sum * _classPrivateFieldGet(this, _state).meta.count;\n  }\n\n  get parent() {\n    return _classPrivateFieldGet(this, _state).molecule.findById(_classPrivateFieldGet(this, _state).molecule.childIds[_classPrivateFieldGet(this, _state).id]);\n  }\n\n}\n\nvar _state = new WeakMap();\n\nmodule.exports = Subgroup;"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A","sourceRoot":""}